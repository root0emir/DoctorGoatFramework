#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
System hardening module for applying security configurations
"""

import os
import sys
import logging
import platform
import subprocess
import shutil
import re
import tempfile
from pathlib import Path

logger = logging.getLogger("doctorgoat.system_hardening")

class SystemHardening:
    """System hardening implementation class"""
    
    def __init__(self, config_data, security_level="medium"):
        """
        Initialize the system hardening module
        
        Args:
            config_data (dict): Configuration data
            security_level (str): Security level (low, medium, high, extreme)
        """
        self.config_data = config_data
        self.security_level = security_level
        self.results = {}
        
        # Define security levels and their corresponding settings
        self.security_levels = {
            "low": {
                "kernel_params": self._get_kernel_params_low(),
                "ssh_config": self._get_ssh_config_low(),
                "firewall_rules": self._get_firewall_rules_low(),
                "auth_settings": self._get_auth_settings_low(),
                "file_permissions": self._get_file_permissions_low()
            },
            "medium": {
                "kernel_params": self._get_kernel_params_medium(),
                "ssh_config": self._get_ssh_config_medium(),
                "firewall_rules": self._get_firewall_rules_medium(),
                "auth_settings": self._get_auth_settings_medium(),
                "file_permissions": self._get_file_permissions_medium()
            },
            "high": {
                "kernel_params": self._get_kernel_params_high(),
                "ssh_config": self._get_ssh_config_high(),
                "firewall_rules": self._get_firewall_rules_high(),
                "auth_settings": self._get_auth_settings_high(),
                "file_permissions": self._get_file_permissions_high()
            },
            "extreme": {
                "kernel_params": self._get_kernel_params_extreme(),
                "ssh_config": self._get_ssh_config_extreme(),
                "firewall_rules": self._get_firewall_rules_extreme(),
                "auth_settings": self._get_auth_settings_extreme(),
                "file_permissions": self._get_file_permissions_extreme()
            }
        }
    
    def harden_kernel(self):
        """
        Apply kernel security parameters via sysctl.conf
        
        Returns:
            dict: Results of the hardening operation
        """
        logger.info(f"Hardening kernel with {self.security_level} security level")
        
        result = {
            "success": False,
            "applied_params": [],
            "failed_params": [],
            "errors": []
        }
        
        if platform.system() != "Linux":
            logger.warning("Kernel hardening is only supported on Linux")
            result["errors"].append("Kernel hardening is only supported on Linux")
            return result
        
        try:
            # Get kernel parameters for the selected security level
            kernel_params = self.security_levels[self.security_level]["kernel_params"]
            
            # Create a backup of the current sysctl.conf
            sysctl_conf = "/etc/sysctl.conf"
            backup_file = f"{sysctl_conf}.backup.{os.getpid()}"
            
            if os.path.exists(sysctl_conf):
                shutil.copy2(sysctl_conf, backup_file)
                logger.info(f"Created backup of sysctl.conf: {backup_file}")
                result["backup_file"] = backup_file
            
            # Read the current sysctl.conf
            current_content = ""
            if os.path.exists(sysctl_conf):
                with open(sysctl_conf, "r") as f:
                    current_content = f.read()
            
            # Create a temporary file for the new sysctl.conf
            with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                # Write header
                temp_file.write("# sysctl.conf generated by DoctorGoatFramework\n")
                temp_file.write(f"# Security level: {self.security_level}\n")
                temp_file.write("# Date: {}\n\n".format(
                    subprocess.check_output(["date"]).decode().strip()
                ))
                
                # Keep existing non-conflicting settings
                for line in current_content.splitlines():
                    line = line.strip()
                    if not line or line.startswith("#"):
                        temp_file.write(line + "\n")
                        continue
                    
                    # Skip parameters that we're going to set
                    param = line.split("=")[0].strip()
                    if param in kernel_params:
                        continue
                    
                    temp_file.write(line + "\n")
                
                # Add our security parameters
                temp_file.write("\n# Security parameters set by DoctorGoatFramework\n")
                for param, value in kernel_params.items():
                    temp_file.write(f"{param} = {value}\n")
                    result["applied_params"].append(f"{param}={value}")
                
                temp_file_path = temp_file.name
            
            # Copy the temporary file to sysctl.conf
            shutil.copy2(temp_file_path, sysctl_conf)
            os.unlink(temp_file_path)
            
            # Apply the new settings
            apply_result = subprocess.run(
                ["sysctl", "-p"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if apply_result.returncode != 0:
                logger.error(f"Failed to apply sysctl settings: {apply_result.stderr}")
                result["errors"].append(f"Failed to apply sysctl settings: {apply_result.stderr}")
                
                # Restore the backup
                if os.path.exists(backup_file):
                    shutil.copy2(backup_file, sysctl_conf)
                    logger.info("Restored sysctl.conf backup due to error")
                
                return result
            
            # Check if the parameters were actually applied
            check_result = subprocess.run(
                ["sysctl", "-a"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if check_result.returncode == 0:
                current_params = {}
                for line in check_result.stdout.splitlines():
                    if "=" in line:
                        key, value = line.split("=", 1)
                        current_params[key.strip()] = value.strip()
                
                # Verify each parameter
                for param, expected in kernel_params.items():
                    if param in current_params:
                        actual = current_params[param]
                        if actual != expected:
                            logger.warning(f"Parameter {param} has value {actual}, expected {expected}")
                            result["failed_params"].append(f"{param}={actual}!={expected}")
                    else:
                        logger.warning(f"Parameter {param} not found in sysctl output")
                        result["failed_params"].append(f"{param}=not_found")
            
            result["success"] = len(result["failed_params"]) == 0
            logger.info(f"Kernel hardening {'successful' if result['success'] else 'partially successful'}")
            
            return result
        
        except Exception as e:
            logger.error(f"Error hardening kernel: {str(e)}")
            result["errors"].append(str(e))
            return result
    
    def harden_ssh(self):
        """
        Harden SSH server configuration
        
        Returns:
            dict: Results of the hardening operation
        """
        logger.info(f"Hardening SSH with {self.security_level} security level")
        
        result = {
            "success": False,
            "applied_settings": [],
            "failed_settings": [],
            "errors": []
        }
        
        if platform.system() != "Linux":
            logger.warning("SSH hardening is only supported on Linux")
            result["errors"].append("SSH hardening is only supported on Linux")
            return result
        
        try:
            # Get SSH settings for the selected security level
            ssh_config = self.security_levels[self.security_level]["ssh_config"]
            
            # Check if SSH server is installed
            ssh_conf_path = "/etc/ssh/sshd_config"
            if not os.path.exists(ssh_conf_path):
                logger.warning("SSH server configuration not found")
                result["errors"].append("SSH server configuration not found")
                return result
            
            # Create a backup of the current sshd_config
            backup_file = f"{ssh_conf_path}.backup.{os.getpid()}"
            shutil.copy2(ssh_conf_path, backup_file)
            logger.info(f"Created backup of sshd_config: {backup_file}")
            result["backup_file"] = backup_file
            
            # Read the current sshd_config
            with open(ssh_conf_path, "r") as f:
                current_content = f.read()
            
            # Create a temporary file for the new sshd_config
            with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                # Write header
                temp_file.write("# sshd_config hardened by DoctorGoatFramework\n")
                temp_file.write(f"# Security level: {self.security_level}\n")
                temp_file.write("# Date: {}\n\n".format(
                    subprocess.check_output(["date"]).decode().strip()
                ))
                
                # Process the existing config
                modified_content = current_content
                for setting, value in ssh_config.items():
                    # Check if the setting already exists
                    pattern = re.compile(r"^#?\s*" + re.escape(setting) + r"\s+.*$", re.MULTILINE)
                    if pattern.search(modified_content):
                        # Replace the existing setting
                        modified_content = pattern.sub(f"{setting} {value}", modified_content)
                        result["applied_settings"].append(f"{setting}={value} (modified)")
                    else:
                        # Add the setting at the end
                        modified_content += f"\n{setting} {value}"
                        result["applied_settings"].append(f"{setting}={value} (added)")
                
                temp_file.write(modified_content)
                temp_file_path = temp_file.name
            
            # Copy the temporary file to sshd_config
            shutil.copy2(temp_file_path, ssh_conf_path)
            os.unlink(temp_file_path)
            
            # Check the configuration syntax
            check_result = subprocess.run(
                ["sshd", "-t"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if check_result.returncode != 0:
                logger.error(f"SSH configuration syntax error: {check_result.stderr}")
                result["errors"].append(f"SSH configuration syntax error: {check_result.stderr}")
                
                # Restore the backup
                shutil.copy2(backup_file, ssh_conf_path)
                logger.info("Restored sshd_config backup due to syntax error")
                
                return result
            
            # Restart the SSH service
            restart_result = subprocess.run(
                ["systemctl", "restart", "sshd"],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if restart_result.returncode != 0:
                logger.error(f"Failed to restart SSH service: {restart_result.stderr}")
                result["errors"].append(f"Failed to restart SSH service: {restart_result.stderr}")
                
                # Restore the backup
                shutil.copy2(backup_file, ssh_conf_path)
                logger.info("Restored sshd_config backup due to restart error")
                
                return result
            
            result["success"] = True
            logger.info("SSH hardening successful")
            
            return result
        
        except Exception as e:
            logger.error(f"Error hardening SSH: {str(e)}")
            result["errors"].append(str(e))
            return result
    
    def harden_firewall(self):
        """
        Configure and optimize firewall rules
        
        Returns:
            dict: Results of the hardening operation
        """
        logger.info(f"Configuring firewall with {self.security_level} security level")
        
        result = {
            "success": False,
            "applied_rules": [],
            "failed_rules": [],
            "errors": []
        }
        
        # Implementation for firewall hardening
        # This would configure iptables or firewalld based on the security level
        
        return result
    
    def harden_authentication(self):
        """
        Harden authentication mechanisms
        
        Returns:
            dict: Results of the hardening operation
        """
        logger.info(f"Hardening authentication with {self.security_level} security level")
        
        result = {
            "success": False,
            "applied_settings": [],
            "failed_settings": [],
            "errors": []
        }
        
        # Implementation for authentication hardening
        # This would configure PAM, login.defs, etc.
        
        return result
    
    def harden_permissions(self):
        """
        Harden file permissions
        
        Returns:
            dict: Results of the hardening operation
        """
        logger.info(f"Hardening file permissions with {self.security_level} security level")
        
        result = {
            "success": False,
            "fixed_permissions": [],
            "failed_permissions": [],
            "errors": []
        }
        
        # Implementation for file permission hardening
        
        return result
    
    def configure_auto_updates(self):
        """
        Configure automatic security updates
        
        Returns:
            dict: Results of the configuration operation
        """
        logger.info("Configuring automatic security updates")
        
        result = {
            "success": False,
            "applied_settings": [],
            "errors": []
        }
        
        # Implementation for automatic updates configuration
        
        return result
    
    # Helper methods to define security parameters for different levels
    
    def _get_kernel_params_low(self):
        """Get kernel parameters for low security level"""
        return {
            "net.ipv4.conf.all.accept_redirects": "0",
            "net.ipv4.conf.default.accept_redirects": "0",
            "net.ipv4.conf.all.accept_source_route": "0",
            "net.ipv4.conf.default.accept_source_route": "0",
            "net.ipv4.icmp_echo_ignore_broadcasts": "1",
            "net.ipv4.icmp_ignore_bogus_error_responses": "1",
            "net.ipv4.tcp_syncookies": "1",
            "net.ipv6.conf.all.accept_redirects": "0",
            "net.ipv6.conf.default.accept_redirects": "0",
            "kernel.randomize_va_space": "2",
            "fs.protected_hardlinks": "1",
            "fs.protected_symlinks": "1"
        }
    
    def _get_kernel_params_medium(self):
        """Get kernel parameters for medium security level"""
        params = self._get_kernel_params_low()
        params.update({
            "net.ipv4.conf.all.rp_filter": "1",
            "net.ipv4.conf.default.rp_filter": "1",
            "net.ipv4.tcp_max_syn_backlog": "2048",
            "net.ipv4.tcp_synack_retries": "2",
            "net.ipv4.tcp_syn_retries": "5",
            "kernel.kptr_restrict": "1",
            "kernel.dmesg_restrict": "1",
            "kernel.perf_event_paranoid": "2",
            "kernel.yama.ptrace_scope": "1",
            "kernel.core_uses_pid": "1",
            "vm.mmap_min_addr": "65536",
            "fs.suid_dumpable": "0"
        })
        return params
    
    def _get_kernel_params_high(self):
        """Get kernel parameters for high security level"""
        params = self._get_kernel_params_medium()
        params.update({
            "net.ipv4.conf.all.log_martians": "1",
            "net.ipv4.conf.default.log_martians": "1",
            "net.ipv4.tcp_rfc1337": "1",
            "net.ipv4.tcp_timestamps": "0",
            "kernel.kptr_restrict": "2",
            "kernel.perf_event_paranoid": "3",
            "kernel.yama.ptrace_scope": "2",
            "kernel.unprivileged_bpf_disabled": "1",
            "kernel.sysrq": "4"
        })
        return params
    
    def _get_kernel_params_extreme(self):
        """Get kernel parameters for extreme security level"""
        params = self._get_kernel_params_high()
        params.update({
            "net.ipv4.conf.all.send_redirects": "0",
            "net.ipv4.conf.default.send_redirects": "0",
            "net.ipv4.ip_forward": "0",
            "kernel.sysrq": "0",
            "kernel.yama.ptrace_scope": "3",
            "vm.unprivileged_userfaultfd": "0"
        })
        return params
    
    def _get_ssh_config_low(self):
        """Get SSH configuration for low security level"""
        return {
            "Protocol": "2",
            "PermitRootLogin": "no",
            "PasswordAuthentication": "yes",
            "PermitEmptyPasswords": "no",
            "X11Forwarding": "no",
            "MaxAuthTries": "4",
            "ClientAliveInterval": "300",
            "ClientAliveCountMax": "0"
        }
    
    def _get_ssh_config_medium(self):
        """Get SSH configuration for medium security level"""
        config = self._get_ssh_config_low()
        config.update({
            "PasswordAuthentication": "no",
            "PubkeyAuthentication": "yes",
            "IgnoreRhosts": "yes",
            "HostbasedAuthentication": "no",
            "PermitUserEnvironment": "no",
            "Ciphers": "chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr",
            "KexAlgorithms": "curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256",
            "MACs": "hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com",
            "LogLevel": "VERBOSE"
        })
        return config
    
    def _get_ssh_config_high(self):
        """Get SSH configuration for high security level"""
        config = self._get_ssh_config_medium()
        config.update({
            "AllowUsers": "",  # Specify allowed users
            "AllowGroups": "sshusers",  # Specify allowed groups
            "LoginGraceTime": "30",
            "MaxStartups": "3:50:10",
            "MaxSessions": "2",
            "TCPKeepAlive": "no",
            "UseDNS": "no",
            "Banner": "/etc/issue.net",
            "DebianBanner": "no",
            "PrintMotd": "no",
            "PrintLastLog": "yes",
            "StrictModes": "yes",
            "Compression": "no",
            "AllowAgentForwarding": "no",
            "AllowTcpForwarding": "no",
            "GatewayPorts": "no",
            "PermitTunnel": "no",
            "AuthenticationMethods": "publickey"
        })
        return config
    
    def _get_ssh_config_extreme(self):
        """Get SSH configuration for extreme security level"""
        config = self._get_ssh_config_high()
        config.update({
            "Port": "22222",  # Non-standard port
            "ListenAddress": "192.168.1.1",  # Specific IP only
            "LoginGraceTime": "20",
            "MaxAuthTries": "2",
            "ClientAliveInterval": "120",
            "MaxStartups": "2:50:5",
            "MaxSessions": "1",
            "ChrootDirectory": "%h",
            "ForceCommand": "internal-sftp",
            "AllowStreamLocalForwarding": "no",
            "DisableForwarding": "yes"
        })
        return config
    
    def _get_firewall_rules_low(self):
        """Get firewall rules for low security level"""
        return []
    
    def _get_firewall_rules_medium(self):
        """Get firewall rules for medium security level"""
        return []
    
    def _get_firewall_rules_high(self):
        """Get firewall rules for high security level"""
        return []
    
    def _get_firewall_rules_extreme(self):
        """Get firewall rules for extreme security level"""
        return []
    
    def _get_auth_settings_low(self):
        """Get authentication settings for low security level"""
        return {}
    
    def _get_auth_settings_medium(self):
        """Get authentication settings for medium security level"""
        return {}
    
    def _get_auth_settings_high(self):
        """Get authentication settings for high security level"""
        return {}
    
    def _get_auth_settings_extreme(self):
        """Get authentication settings for extreme security level"""
        return {}
    
    def _get_file_permissions_low(self):
        """Get file permission settings for low security level"""
        return {}
    
    def _get_file_permissions_medium(self):
        """Get file permission settings for medium security level"""
        return {}
    
    def _get_file_permissions_high(self):
        """Get file permission settings for high security level"""
        return {}
    
    def _get_file_permissions_extreme(self):
        """Get file permission settings for extreme security level"""
        return {}
